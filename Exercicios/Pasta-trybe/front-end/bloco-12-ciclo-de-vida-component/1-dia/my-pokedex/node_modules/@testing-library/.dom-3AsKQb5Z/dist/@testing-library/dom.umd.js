(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TestingLibraryDom = {}));
})(this, (function (exports) { 'use strict';

	function _mergeNamespaces(n, m) {
		m.forEach(function (e) {
			e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
				if (k !== 'default' && !(k in n)) {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		});
		return Object.freeze(n);
	}

	var build = {};

	var ansiStyles = {exports: {}};

	(function (module) {

	  const ANSI_BACKGROUND_OFFSET = 10;

	  const wrapAnsi256 = function (offset) {
	    if (offset === void 0) {
	      offset = 0;
	    }

	    return code => "\x1B[" + (38 + offset) + ";5;" + code + "m";
	  };

	  const wrapAnsi16m = function (offset) {
	    if (offset === void 0) {
	      offset = 0;
	    }

	    return (red, green, blue) => "\x1B[" + (38 + offset) + ";2;" + red + ";" + green + ";" + blue + "m";
	  };

	  function assembleStyles() {
	    const codes = new Map();
	    const styles = {
	      modifier: {
	        reset: [0, 0],
	        // 21 isn't widely supported and 22 does the same thing
	        bold: [1, 22],
	        dim: [2, 22],
	        italic: [3, 23],
	        underline: [4, 24],
	        overline: [53, 55],
	        inverse: [7, 27],
	        hidden: [8, 28],
	        strikethrough: [9, 29]
	      },
	      color: {
	        black: [30, 39],
	        red: [31, 39],
	        green: [32, 39],
	        yellow: [33, 39],
	        blue: [34, 39],
	        magenta: [35, 39],
	        cyan: [36, 39],
	        white: [37, 39],
	        // Bright color
	        blackBright: [90, 39],
	        redBright: [91, 39],
	        greenBright: [92, 39],
	        yellowBright: [93, 39],
	        blueBright: [94, 39],
	        magentaBright: [95, 39],
	        cyanBright: [96, 39],
	        whiteBright: [97, 39]
	      },
	      bgColor: {
	        bgBlack: [40, 49],
	        bgRed: [41, 49],
	        bgGreen: [42, 49],
	        bgYellow: [43, 49],
	        bgBlue: [44, 49],
	        bgMagenta: [45, 49],
	        bgCyan: [46, 49],
	        bgWhite: [47, 49],
	        // Bright color
	        bgBlackBright: [100, 49],
	        bgRedBright: [101, 49],
	        bgGreenBright: [102, 49],
	        bgYellowBright: [103, 49],
	        bgBlueBright: [104, 49],
	        bgMagentaBright: [105, 49],
	        bgCyanBright: [106, 49],
	        bgWhiteBright: [107, 49]
	      }
	    }; // Alias bright black as gray (and grey)

	    styles.color.gray = styles.color.blackBright;
	    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	    styles.color.grey = styles.color.blackBright;
	    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	    for (const [groupName, group] of Object.entries(styles)) {
	      for (const [styleName, style] of Object.entries(group)) {
	        styles[styleName] = {
	          open: "\x1B[" + style[0] + "m",
	          close: "\x1B[" + style[1] + "m"
	        };
	        group[styleName] = styles[styleName];
	        codes.set(style[0], style[1]);
	      }

	      Object.defineProperty(styles, groupName, {
	        value: group,
	        enumerable: false
	      });
	    }

	    Object.defineProperty(styles, 'codes', {
	      value: codes,
	      enumerable: false
	    });
	    styles.color.close = '\u001B[39m';
	    styles.bgColor.close = '\u001B[49m';
	    styles.color.ansi256 = wrapAnsi256();
	    styles.color.ansi16m = wrapAnsi16m();
	    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET); // From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c7209